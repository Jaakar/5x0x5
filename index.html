<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SG-0 : 5x0x5 Visualization</title>

  <!-- Sci-fi + UI mono fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-color: #050505;
      --text-color: #a0a0a0;
      --accent-color: #00ffd5;

      --font-ui: "Share Tech Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --font-logo: "Orbitron", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: var(--bg-color);
      color: var(--text-color);
      font-family: var(--font-ui);
    }

    #canvas-container {
      position: absolute;
      inset: 0;
      z-index: 0;
      background: radial-gradient(circle at center, rgba(0,0,0,0) 0%, rgba(0,0,0,0.85) 100%);
    }

    #ui-overlay {
      position: absolute;
      inset: 0;
      z-index: 10;
      pointer-events: none;
      padding: 2rem;
      box-sizing: border-box;
    }

    header {
      text-transform: uppercase;
      letter-spacing: 3px;
      font-size: 0.72rem;
      color: var(--accent-color);
      opacity: 0.85;
    }

    .main-title {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      width: min(92vw, 900px);
    }

    .domain-id {
      margin: 0;
      font-family: var(--font-logo);
      font-size: clamp(3.2rem, 8vw, 5.2rem);
      font-weight: 700;
      letter-spacing: 0.18em;
      color: #fff;
      text-shadow: 0 0 28px rgba(0, 255, 213, 0.55);

      /* helps digits look consistent */
      font-variant-numeric: tabular-nums;
      -webkit-font-smoothing: antialiased;
      text-rendering: geometricPrecision;
    }

    /* Remove the “letter-spacing pushes center” feel by re-centering visually */
    .domain-id > span {
      display: inline-block;
      transform: translateX(0.09em); /* half of letter-spacing */
    }

    .subtitle {
      margin-top: 1rem;
      font-size: 0.95rem;
      letter-spacing: 2px;
      text-transform: uppercase;
      opacity: 0.6;
    }

    .quote-box {
      position: absolute;
      left: 2rem;
      bottom: 2rem;
      max-width: 360px;
      font-size: 0.85rem;
      line-height: 1.6;
      opacity: 0.7;
      border-left: 3px solid var(--accent-color);
      padding-left: 1rem;
    }

    @media (max-width: 600px) {
      #ui-overlay { padding: 1.25rem; }

      header { letter-spacing: 2px; }

      .subtitle {
        font-size: 0.8rem;
        margin-top: 0.8rem;
      }

      .quote-box {
        left: 1.25rem;
        bottom: 1.25rem;
        max-width: 85vw;
      }
    }
  </style>
</head>

<body>
  <div id="canvas-container"></div>

  <div id="ui-overlay">
    <header>SG-0 // Structure Class: Pentagonal</header>

    <div class="main-title">
      <h1 class="domain-id"><span>505</span></h1>
      <div class="subtitle">Pentagonal Symmetry Network</div>
    </div>

    <div class="quote-box">
      "When a domain is not a word, but a structure, it can be visualized as a mathematical object."
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    let scene, camera, renderer;
    let centerAnchorGroup;
    let leftPentagonGroup, rightPentagonGroup;
    let pointerX = 0, pointerY = 0;

    const CONFIG = {
      colorFive: 0x00ffd5,
      colorZero: 0xffffff,
      separation: 7,
      rotationSpeed: 0.002,
      fogDensity: 0.025
    };

    function init() {
      const container = document.getElementById("canvas-container");
      container.innerHTML = ""; // avoid duplicates on hot reloads

      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050505, CONFIG.fogDensity);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 18;

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setClearColor(0x000000, 0); // transparent clear
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      container.appendChild(renderer.domElement);

      createLighting();

      createCenterZero();

      leftPentagonGroup = createPentagonalComplex(CONFIG.colorFive);
      leftPentagonGroup.position.x = -CONFIG.separation;
      scene.add(leftPentagonGroup);

      rightPentagonGroup = createPentagonalComplex(CONFIG.colorFive);
      rightPentagonGroup.position.x = CONFIG.separation;
      rightPentagonGroup.rotation.y = Math.PI;
      scene.add(rightPentagonGroup);

      window.addEventListener("resize", onWindowResize, { passive: true });
      window.addEventListener("pointermove", onPointerMove, { passive: true });

      animate();
    }

    function createLighting() {
      scene.add(new THREE.AmbientLight(0x222222));

      const centerLight = new THREE.PointLight(CONFIG.colorZero, 1, 40);
      centerLight.position.set(0, 0, 0);
      scene.add(centerLight);

      const sideLightL = new THREE.DirectionalLight(CONFIG.colorFive, 1.5);
      sideLightL.position.set(-15, 10, 5);
      scene.add(sideLightL);

      const sideLightR = new THREE.DirectionalLight(CONFIG.colorFive, 1.5);
      sideLightR.position.set(15, -10, 5);
      scene.add(sideLightR);
    }

    function createCenterZero() {
      centerAnchorGroup = new THREE.Group();

      const coreGeo = new THREE.SphereGeometry(0.5, 32, 32);
      const coreMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colorZero,
        emissive: CONFIG.colorZero,
        emissiveIntensity: 1,
        roughness: 0
      });
      centerAnchorGroup.add(new THREE.Mesh(coreGeo, coreMat));

      const cageGeo = new THREE.IcosahedronGeometry(1.2, 0);
      const cageMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colorZero,
        wireframe: true,
        transparent: true,
        opacity: 0.3
      });
      centerAnchorGroup.cageMesh = new THREE.Mesh(cageGeo, cageMat);
      centerAnchorGroup.add(centerAnchorGroup.cageMesh);

      const particleGeo = new THREE.BufferGeometry();
      const particleCount = 300;
      const posArray = new Float32Array(particleCount * 3);
      for (let i = 0; i < particleCount * 3; i++) {
        posArray[i] = (Math.random() - 0.5) * 6;
      }
      particleGeo.setAttribute("position", new THREE.BufferAttribute(posArray, 3));

      const particleMat = new THREE.PointsMaterial({
        size: 0.03,
        color: CONFIG.colorZero,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      });
      centerAnchorGroup.add(new THREE.Points(particleGeo, particleMat));

      scene.add(centerAnchorGroup);
    }

    function createPentagonalComplex(color) {
      const group = new THREE.Group();
      const geometry = new THREE.DodecahedronGeometry(2.8, 0);

      const crystalMat = new THREE.MeshPhysicalMaterial({
        color,
        metalness: 0.2,
        roughness: 0.1,
        transmission: 0.8,
        ior: 1.5,
        thickness: 2.0,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.9
      });
      group.add(new THREE.Mesh(geometry, crystalMat));

      const wireframeMat = new THREE.MeshBasicMaterial({
        color,
        wireframe: true,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending
      });
      const wireframeMesh = new THREE.Mesh(geometry, wireframeMat);
      wireframeMesh.scale.set(1.01, 1.01, 1.01);
      group.add(wireframeMesh);

      return group;
    }

    function animate() {
      requestAnimationFrame(animate);
      const time = Date.now() * 0.001;

      centerAnchorGroup.cageMesh.rotation.x += 0.01;
      centerAnchorGroup.cageMesh.rotation.y -= 0.015;
      const pulse = 1 + Math.sin(time * 1.5) * 0.05;
      centerAnchorGroup.scale.set(pulse, pulse, pulse);

      leftPentagonGroup.rotation.x += CONFIG.rotationSpeed * 1.2;
      leftPentagonGroup.rotation.y += CONFIG.rotationSpeed;
      leftPentagonGroup.rotation.z += CONFIG.rotationSpeed * 0.5;

      rightPentagonGroup.rotation.x -= CONFIG.rotationSpeed * 1.2;
      rightPentagonGroup.rotation.y -= CONFIG.rotationSpeed;
      rightPentagonGroup.rotation.z -= CONFIG.rotationSpeed * 0.5;

      // Pointer -> smooth camera drift
      const targetX = pointerX * 6.0;
      const targetY = pointerY * 6.0;
      camera.position.x += (targetX - camera.position.x) * 0.05;
      camera.position.y += (targetY - camera.position.y) * 0.05;
      camera.lookAt(scene.position);

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onPointerMove(e) {
      const x = (e.clientX / window.innerWidth) * 2 - 1;
      const y = -(e.clientY / window.innerHeight) * 2 + 1;
      pointerX = x;
      pointerY = y;
    }

    init();
  </script>
</body>
</html>
