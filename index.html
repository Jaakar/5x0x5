<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SG-0 : 5x0x5</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#050505;
      --accent:#00ffd5;
      --code:#00ffd5;
    }
    html, body{
      margin:0; padding:0;
      height:100%;
      overflow:hidden;
      background:var(--bg);
    }

    #canvas-container{
      position:absolute;
      inset:0;
      z-index:0;
      background: radial-gradient(circle at center, rgba(0,0,0,0) 0%, rgba(0,0,0,0.85) 100%);
    }

    /* --- Ambient edge glow (left/right) --- */
    .ambient{
      position:absolute;
      top:0; bottom:0;
      width: 32vw;
      z-index: 3;              /* canvasin päällä, koodin ja otsikon alla */
      pointer-events:none;
      opacity: 0.28;
      filter: blur(22px);
      mix-blend-mode: screen;
      animation: ambientBreath 7s ease-in-out infinite;
    }
    .ambient-left{
      left:-10vw;
      background: radial-gradient(circle at 30% 50%,
        rgba(0,255,213,0.22) 0%,
        rgba(0,255,213,0.10) 30%,
        rgba(0,0,0,0) 68%);
    }
    .ambient-right{
      right:-10vw;
      background: radial-gradient(circle at 70% 50%,
        rgba(0,255,213,0.22) 0%,
        rgba(0,255,213,0.10) 30%,
        rgba(0,0,0,0) 68%);
      animation-delay: -3.5s;
    }
    @keyframes ambientBreath{
      0%,100%{ opacity:0.18; transform: translateY(0px); }
      50%{ opacity:0.34; transform: translateY(-6px); }
    }

    /* Center title */
    #ui{
      position:absolute;
      inset:0;
      z-index:10;
      pointer-events:none;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 1rem;
      box-sizing:border-box;
    }
    .domain-id{
      margin:0;
      font-family:"Orbitron", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-weight:700;
      color:#fff;
      font-size: clamp(2.6rem, 10vw, 5.2rem);
      letter-spacing: 0.12em;
      text-shadow: 0 0 28px rgba(0,255,213,0.55);
      font-variant-numeric: tabular-nums;
      -webkit-font-smoothing: antialiased;
      text-rendering: geometricPrecision;
    }
    .domain-id > span{
      display:inline-block;
      transform: translateX(0.06em);
    }

    /* Faint math/code strips (top & bottom) */
    .code-strip{
      position:absolute;
      left:0; right:0;
      height: 18vh;
      z-index:9;            /* under title, above ambient and canvas */
      pointer-events:none;
      overflow:hidden;

      font-family: "Share Tech Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color: rgba(0,255,213,0.28);
      text-shadow: 0 0 12px rgba(0,255,213,0.12);
      letter-spacing: 0.08em;
      line-height: 1.35;
      font-size: 0.72rem;
      -webkit-font-smoothing: antialiased;
    }
    .code-strip.top{
      top:0;
      mask-image: linear-gradient(to bottom, rgba(0,0,0,0.75), rgba(0,0,0,0.25), rgba(0,0,0,0));
      -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,0.75), rgba(0,0,0,0.25), rgba(0,0,0,0));
    }
    .code-strip.bottom{
      bottom:0;
      mask-image: linear-gradient(to top, rgba(0,0,0,0.75), rgba(0,0,0,0.25), rgba(0,0,0,0));
      -webkit-mask-image: linear-gradient(to top, rgba(0,0,0,0.75), rgba(0,0,0,0.25), rgba(0,0,0,0));
    }

    .code-scroll{
      position:absolute;
      left:0; right:0;
      padding: 1.2rem 1.2rem;
      box-sizing:border-box;
      white-space: pre;
      opacity: 0.75;
    }

    /* Scroll animations */
    .top .code-scroll{ animation: scrollDown 18s linear infinite; }
    .bottom .code-scroll{ animation: scrollUp 18s linear infinite; }

    /* subtle flicker */
    .code-strip::after{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(circle at 50% 50%, rgba(0,255,213,0.06), transparent 60%);
      opacity: 0.5;
      animation: shimmer 6s ease-in-out infinite;
      pointer-events:none;
    }

    @keyframes scrollDown{
      from{ transform: translateY(-35%); }
      to  { transform: translateY(0%); }
    }
    @keyframes scrollUp{
      from{ transform: translateY(0%); }
      to  { transform: translateY(-35%); }
    }
    @keyframes shimmer{
      0%,100%{ opacity:0.35; }
      50%{ opacity:0.6; }
    }

    @media (prefers-reduced-motion: reduce){
      .top .code-scroll, .bottom .code-scroll, .code-strip::after, .ambient{ animation:none !important; }
    }
  </style>
</head>

<body>
  <div id="canvas-container"></div>

  <!-- Ambient edge glow -->
  <div class="ambient ambient-left"></div>
  <div class="ambient ambient-right"></div>

  <div class="code-strip top"><div class="code-scroll" id="codeTop"></div></div>
  <div class="code-strip bottom"><div class="code-scroll" id="codeBottom"></div></div>

  <div id="ui">
    <h1 class="domain-id"><span>5x0x5</span></h1>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let centerAnchorGroup;
    let leftPentagonGroup, rightPentagonGroup;

    // pointer (mobiili + desktop)
    let pointerNDC = new THREE.Vector2(0, 0);

    // repulsion physics
    const centerOffset = new THREE.Vector3(0, 0, 0);
    const centerVelocity = new THREE.Vector3(0, 0, 0);

    const CONFIG = {
      colorFive: 0x00ffd5,
      colorZero: 0xffffff,
      separation: 7,
      rotationSpeed: 0.002,
      fogDensity: 0.025
    };

    // --------- CLICK SOUND (WebAudio, no files) ----------
    let audioCtx = null;

    function ensureAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") audioCtx.resume();
    }

    function playClickSound(pan = 0) {
      try {
        ensureAudio();
        const t0 = audioCtx.currentTime;

        const master = audioCtx.createGain();
        master.gain.setValueAtTime(0.0001, t0);
        master.gain.exponentialRampToValueAtTime(0.22, t0 + 0.01);
        master.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.18);

        // stereo panner (fallback if not supported)
        let outNode = master;
        if (audioCtx.createStereoPanner) {
          const panner = audioCtx.createStereoPanner();
          panner.pan.setValueAtTime(Math.max(-0.8, Math.min(0.8, pan)), t0);
          master.connect(panner);
          outNode = panner;
        }
        outNode.connect(audioCtx.destination);

        // sci-fi ping
        const osc = audioCtx.createOscillator();
        const oscGain = audioCtx.createGain();
        osc.type = "triangle";
        osc.frequency.setValueAtTime(880, t0);
        osc.frequency.exponentialRampToValueAtTime(520, t0 + 0.06);
        oscGain.gain.setValueAtTime(0.0001, t0);
        oscGain.gain.exponentialRampToValueAtTime(0.9, t0 + 0.008);
        oscGain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.12);
        osc.connect(oscGain).connect(master);

        // noise spark
        const noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.08, audioCtx.sampleRate);
        const data = noiseBuf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);

        const noise = audioCtx.createBufferSource();
        noise.buffer = noiseBuf;

        const hp = audioCtx.createBiquadFilter();
        hp.type = "highpass";
        hp.frequency.setValueAtTime(1800, t0);

        const noiseGain = audioCtx.createGain();
        noiseGain.gain.setValueAtTime(0.0001, t0);
        noiseGain.gain.exponentialRampToValueAtTime(0.55, t0 + 0.004);
        noiseGain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.08);

        noise.connect(hp).connect(noiseGain).connect(master);

        // tiny sub thump (stealth)
        const sub = audioCtx.createOscillator();
        const subGain = audioCtx.createGain();
        sub.type = "sine";
        sub.frequency.setValueAtTime(110, t0);
        sub.frequency.exponentialRampToValueAtTime(70, t0 + 0.10);
        subGain.gain.setValueAtTime(0.0001, t0);
        subGain.gain.exponentialRampToValueAtTime(0.22, t0 + 0.01);
        subGain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.16);
        sub.connect(subGain).connect(master);

        osc.start(t0);  osc.stop(t0 + 0.20);
        noise.start(t0); noise.stop(t0 + 0.10);
        sub.start(t0);  sub.stop(t0 + 0.20);
      } catch (e) {
        // ignore audio errors (e.g., strict mobile policies)
      }
    }

    // --------- CODE STRIPS (faint math computing) ----------
    const CHARSET = "0123456789ABCDEF+-*/=<>[](){}.,:;_|~^";
    const GREEK = ["Φ","Σ","Ω","Δ","λ","π","μ","η","ψ","∇","∂","∞"];
    const TOKENS = [
      "SG-0","X0X","PENT","DODEC","ICOSA","FFT","MATRIX","EIGEN","NORM","PRIME",
      "HASH","UID","ENTROPY","FLOW","STATE","VECTOR","TENSOR","FIELD","SYMM"
    ];

    function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
    function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

    function randomMathLine(width=64){
      const a = pick(TOKENS);
      const b = pick(TOKENS);
      const g = pick(GREEK);

      let core =
        `${a} ${g}=${pick(GREEK)}  ` +
        `A[${randInt(0,9)},${randInt(0,9)}]·B[${randInt(0,9)},${randInt(0,9)}] -> ` +
        `${b}:${randInt(10,99)}  ` +
        `∑k=${randInt(1,9)}  ` +
        `|x|=${(Math.random()*9).toFixed(3)}  ` +
        `h=${randInt(1000,9999).toString(16).toUpperCase()}`;

      while(core.length < width){
        core += CHARSET[Math.floor(Math.random()*CHARSET.length)];
      }
      return core.slice(0, width);
    }

    function buildCodeBlock(lines=28, width=66){
      const out = [];
      for(let i=0;i<lines;i++) out.push(randomMathLine(width));
      return out.join("\n");
    }

    function mutateText(el, mutations=10){
      const txt = el.textContent;
      if(!txt) return;
      const arr = txt.split("");
      for(let i=0;i<mutations;i++){
        const idx = randInt(0, arr.length-1);
        if(arr[idx] === "\n") continue;
        if(Math.random() < 0.12) arr[idx] = pick(GREEK);
        else arr[idx] = CHARSET[Math.floor(Math.random()*CHARSET.length)];
      }
      el.textContent = arr.join("");
    }

    function initCodeStrips(){
      const top = document.getElementById("codeTop");
      const bottom = document.getElementById("codeBottom");
      top.textContent = buildCodeBlock(30, 68);
      bottom.textContent = buildCodeBlock(30, 68);

      setInterval(() => mutateText(top, 14), 900);
      setInterval(() => mutateText(bottom, 14), 1000);
    }

    // -------------- THREE.JS SCENE ----------------
    function init(){
      initCodeStrips();

      const container = document.getElementById("canvas-container");
      container.innerHTML = "";

      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050505, CONFIG.fogDensity);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 18;

      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setClearColor(0x000000, 0);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      container.appendChild(renderer.domElement);

      createLighting();
      createCenterZero();

      leftPentagonGroup = createPentagonalComplex(CONFIG.colorFive);
      leftPentagonGroup.position.x = -CONFIG.separation;
      scene.add(leftPentagonGroup);

      rightPentagonGroup = createPentagonalComplex(CONFIG.colorFive);
      rightPentagonGroup.position.x = CONFIG.separation;
      rightPentagonGroup.rotation.y = Math.PI;
      scene.add(rightPentagonGroup);

      window.addEventListener("resize", onWindowResize, { passive:true });
      window.addEventListener("pointermove", onPointerMove, { passive:true });
      window.addEventListener("pointerdown", onPointerDown, { passive:true });

      animate();
    }

    function createLighting(){
      scene.add(new THREE.AmbientLight(0x222222));

      const centerLight = new THREE.PointLight(CONFIG.colorZero, 1, 40);
      centerLight.position.set(0, 0, 0);
      scene.add(centerLight);

      const sideLightL = new THREE.DirectionalLight(CONFIG.colorFive, 1.5);
      sideLightL.position.set(-15, 10, 5);
      scene.add(sideLightL);

      const sideLightR = new THREE.DirectionalLight(CONFIG.colorFive, 1.5);
      sideLightR.position.set(15, -10, 5);
      scene.add(sideLightR);
    }

    function createCenterZero(){
      centerAnchorGroup = new THREE.Group();

      const coreGeo = new THREE.SphereGeometry(0.5, 32, 32);
      const coreMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colorZero,
        emissive: CONFIG.colorZero,
        emissiveIntensity: 1,
        roughness: 0
      });
      centerAnchorGroup.add(new THREE.Mesh(coreGeo, coreMat));

      const cageGeo = new THREE.IcosahedronGeometry(1.2, 0);
      const cageMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colorZero,
        wireframe: true,
        transparent: true,
        opacity: 0.3
      });
      centerAnchorGroup.cageMesh = new THREE.Mesh(cageGeo, cageMat);
      centerAnchorGroup.add(centerAnchorGroup.cageMesh);

      const particleGeo = new THREE.BufferGeometry();
      const particleCount = 300;
      const posArray = new Float32Array(particleCount * 3);
      for (let i=0; i<particleCount*3; i++) posArray[i] = (Math.random() - 0.5) * 6;
      particleGeo.setAttribute("position", new THREE.BufferAttribute(posArray, 3));

      const particleMat = new THREE.PointsMaterial({
        size: 0.03,
        color: CONFIG.colorZero,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      });
      centerAnchorGroup.add(new THREE.Points(particleGeo, particleMat));

      scene.add(centerAnchorGroup);
    }

    function createPentagonalComplex(color){
      const group = new THREE.Group();
      const geometry = new THREE.DodecahedronGeometry(2.8, 0);

      const crystalMat = new THREE.MeshPhysicalMaterial({
        color,
        metalness: 0.2,
        roughness: 0.1,
        transmission: 0.8,
        ior: 1.5,
        thickness: 2.0,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.9
      });
      group.add(new THREE.Mesh(geometry, crystalMat));

      const wireframeMat = new THREE.MeshBasicMaterial({
        color,
        wireframe: true,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending
      });
      const wireframeMesh = new THREE.Mesh(geometry, wireframeMat);
      wireframeMesh.scale.set(1.01, 1.01, 1.01);
      group.add(wireframeMesh);

      return group;
    }

    function onPointerMove(e){
      pointerNDC.x = (e.clientX / window.innerWidth) * 2 - 1;
      pointerNDC.y = -(e.clientY / window.innerHeight) * 2 + 1;
    }

    function onPointerDown(e){
      pointerNDC.x = (e.clientX / window.innerWidth) * 2 - 1;
      pointerNDC.y = -(e.clientY / window.innerHeight) * 2 + 1;

      // sound (click/tap)
      playClickSound(pointerNDC.x);

      // visual click/tap effect
      spawnClickPulse(pointerNDC.x, pointerNDC.y);

      // repulsion impulse (push center away)
      const impulse = new THREE.Vector3(-pointerNDC.x, -pointerNDC.y, 0).multiplyScalar(0.9);
      centerVelocity.add(impulse);
    }

    function spawnClickPulse(nx, ny){
      // position near screen plane
      const pos = new THREE.Vector3(nx * 6, ny * 6, 6);

      // 1) point light pulse
      const light = new THREE.PointLight(CONFIG.colorFive, 2.0, 18, 2.0);
      light.position.copy(pos);
      scene.add(light);

      // 2) glow sphere
      const glowGeo = new THREE.SphereGeometry(0.15, 16, 16);
      const glowMat = new THREE.MeshBasicMaterial({
        color: CONFIG.colorFive,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.copy(pos);
      scene.add(glow);

      // 3) shockwave ring
      const ringGeo = new THREE.RingGeometry(0.35, 0.48, 64);
      const ringMat = new THREE.MeshBasicMaterial({
        color: CONFIG.colorFive,
        transparent: true,
        opacity: 0.55,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.copy(pos);
      scene.add(ring);

      const start = performance.now();
      const duration = 520; // ms

      function fade(){
        const t = (performance.now() - start) / duration;
        if (t >= 1){
          scene.remove(light);
          scene.remove(glow);
          scene.remove(ring);

          glow.geometry.dispose();
          glow.material.dispose();
          ring.geometry.dispose();
          ring.material.dispose();
          return;
        }

        const k = 1 - t;

        light.intensity = 2.0 * k;
        glow.material.opacity = 0.9 * k;
        glow.scale.setScalar(1 + (1 - k) * 3.2);

        ring.material.opacity = 0.55 * k;
        ring.scale.setScalar(1 + (1 - k) * 10.0);

        ring.quaternion.copy(camera.quaternion);

        requestAnimationFrame(fade);
      }
      fade();
    }

    function animate(){
      requestAnimationFrame(animate);
      const time = Date.now() * 0.001;

      // center base animation
      centerAnchorGroup.cageMesh.rotation.x += 0.01;
      centerAnchorGroup.cageMesh.rotation.y -= 0.015;
      const pulse = 1 + Math.sin(time * 1.5) * 0.05;
      centerAnchorGroup.scale.set(pulse, pulse, pulse);

      // rotating side objects
      leftPentagonGroup.rotation.x += CONFIG.rotationSpeed * 1.2;
      leftPentagonGroup.rotation.y += CONFIG.rotationSpeed;
      leftPentagonGroup.rotation.z += CONFIG.rotationSpeed * 0.5;

      rightPentagonGroup.rotation.x -= CONFIG.rotationSpeed * 1.2;
      rightPentagonGroup.rotation.y -= CONFIG.rotationSpeed;
      rightPentagonGroup.rotation.z -= CONFIG.rotationSpeed * 0.5;

      // repulsion spring/damping (return to center)
      const spring = 0.12;
      const damping = 0.86;

      centerVelocity.addScaledVector(centerOffset, -spring);
      centerVelocity.multiplyScalar(damping);
      centerOffset.add(centerVelocity);
      centerOffset.clampLength(0, 2.2);
      centerAnchorGroup.position.set(centerOffset.x, centerOffset.y, 0);

      // subtle camera drift following pointer
      const targetX = pointerNDC.x * 6.0;
      const targetY = pointerNDC.y * 6.0;
      camera.position.x += (targetX - camera.position.x) * 0.04;
      camera.position.y += (targetY - camera.position.y) * 0.04;
      camera.lookAt(scene.position);

      renderer.render(scene, camera);
    }

    function onWindowResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
</body>
</html>
